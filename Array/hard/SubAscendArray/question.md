牛牛现在有一个n个数组成的数列,牛牛现在想取一个连续的子序列,并且这个子序列还必须得满足:最多只改变一个数,就可以使得这个连续的子序列是一个严格上升的子序列,牛牛想知道这个连续子序列最长的长度是多少。

输入描述:
输入包括两行,第一行包括一个整数n(1 ≤ n ≤ 10^5),即数列的长度;
第二行n个整数a_i, 表示数列中的每个数(1 ≤ a_i ≤ 10^9),以空格分割。


输出描述:
输出一个整数,表示最长的长度。

示例1
输入
6 
7 2 3 1 5 6

输出
5

思路：（类似于前缀和）

首先从头到尾遍历数组，统计数组中以下标i结尾的上升子序列的长度, v1数组：(1 1 2 1 2 3)
在从尾到头遍历数组，统计数组中以下标i开始的上升子序列的长度，v2数组：(1 2 1 3 2 1)

因为可以改变一个位置，所以对于原始数组nums当满足：nums[i+1]-nums[i-1] >= 2，即nums[i]改变后，i-1、i、i+1可以变为上升序列
此时，上升子序列长度更新为：v1[i-1]+v2[i+1]+1。
对于i=0，i=nums.size()-1,进行特殊处理，防止nums[i-1]、nums[i+1]访问越界即可。
每遍历一个索引位置，更新最长子序列长度即可

